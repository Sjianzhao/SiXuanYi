/**
  ******************************************************************************
  * @file    Project/STM32F10x_StdPeriph_Template/stm32f10x_it.c 
  * @author  MCD Application Team
  * @version V3.5.0
  * @date    08-April-2011
  * @brief   Main Interrupt Service Routines.
  *          This file provides template for all exceptions handler and 
  *          peripherals interrupt service routine.
  ******************************************************************************
  * @attention
  *
  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
  * DIRECT, INDIRECT OR CONSEQUENTI
  
  AL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  *
  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
#include "stm32f10x_it.h"
#include "bsp_SysTick.h"
#include "GPIO_Config.h"
#include "nR24L01_Reg.h"
#include "irda.h"
#include "LED_config.h"
#include "mpu6050.h"
#include "BMP_280.h"
#include "PID_control.h"

char rx_num;//保存接收的次数
extern void TimingDelay_Decrement(void);
extern char num;//计算一段时间内接收才次数
extern volatile u32 time,times;
extern u8 Ultrasonic,Ultrasonic_OK;


extern uint32_t frame_data;
extern uint8_t  frame_cnt;
extern uint8_t  frame_flag;

uint8_t isr_cnt;  /* 用于计算进了多少次中断 */
uint16_t TIME_AGM=0,TIME_PID=0;//采集时间以及PID 的时间



uint8_t DATA_START;//普通采集标志位
uint8_t PRESS_START;//气压采集标志位
uint8_t Ultrasonic_START;//超声波采集标志位
uint8_t AGM_START;//角度采集标志位
uint8_t TIME_20ms;//20ms标志位

/** @addtogroup STM32F10x_StdPeriph_Template
  * @{
  */

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/******************************************************************************/
/*            Cortex-M3 Processor Exceptions Handlers                         */
/******************************************************************************/

/**
  * @brief  This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
}

/**
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
  {
  }
}

/**
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
  {
  }
}

/**
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
  {
  }
}

/**
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
  {
  }
}

/**
  * @brief  This function handles SVCall exception.
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
}

/**
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
}

/**
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
}

/**
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
	TimingDelay_Decrement();
}

/******************************************************************************/
/*                 STM32F10x Peripherals Interrupt Handlers                   */
/*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
/*  available peripheral interrupt handler's name please refer to the startup */
/*  file (startup_stm32f10x_xx.s).                                            */
/******************************************************************************/

/**
  * @brief  This function handles PPP interrupt request.
  * @param  None
  * @retval None
  */
void TIM6_IRQHandler(void)
{
	if ( TIM_GetITStatus(TIM6 , TIM_IT_Update) != RESET ) 
	{	
//		TIM_ClearITPendingBit(TIM6 , TIM_FLAG_Update);
		
		TIME_AGM++;  //陀螺仪采集时间		
		if(TIME_AGM==5) //5ms中断一次  陀螺仪加速度地磁
		{
//			  PWM_control();//PWM输出控制
			
				TIME_AGM=0;
			
			  AGM_START=1;//采集标志位			
			
		}
		
		TIME_PID++;  //PID处理时间
		time++;
		
    if(time==18)
		{
			get_nrf_sta();				//获取状态标志
//			if(TX_DS)			//发送成功，跳出循环
//			{	
//			}			
			if(RX_DR == 1)				//接收成功
			{	 
				nrf_read(RxBuf);		//接收成功后，将NRF24L01接收到的数据读到单片机的RxBuf数组中。
				num++;//次数
//				printf("ok\n");
			}
			nrf_TxMod();          //发送模式
			nrf_trans(TxBuf);			//将待发送的数据写入NRF24L01
		}
		else if(time==20)//20ms
		{
			TIME_20ms=1;
//			PID_control();//PID控制
			PWM_control();//PWM输出控制
			
			
			nrf_RxMod();          //接收模式
			time=0;
			times++;
		
			if(times==25)//500ms次里面接受的次数
			{
				times=0;
				rx_num=num;
	//			printf("一秒钟接收 %d 次\n",num);			
				 num=0;
	//			LED0_TOGGLE;
			}			
		}
		
		if(TIME_PID==50) //100ms中断一次 气压 超声波 PID
		{
				PRESS_START=1; //气压打开测量
						  			
		}
		else if(TIME_PID==100) //100ms中断一次 气压 超声波 PID
		{
				TIME_PID=0;
			
			  DATA_START=1;//打开普通数据采集	
		}
		
		TIM_ClearITPendingBit(TIM6 , TIM_FLAG_Update);  		 
	}		 	
}

void EXTI1_IRQHandler(void)
{ 
	if(EXTI_GetITStatus(EXTI_Line1) != RESET) //确保是否产生了EXTI Line中断
	{
		if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1))  //1号超声波产生的信号
		{
				TIM_Cmd(TIM7, ENABLE);  //开启定时器
//				Ultrasonic=1; //开启测距标志 防止再次启动
				Ultrasonic_OK=0;//测距开始
//			printf("开\n");
		}	
		else
		{
			  TIM_Cmd(TIM7, DISABLE);   //停止计时器
				Ultrasonic_OK=1;//测距完成   已经完成测距
//				Ultrasonic=0;//关闭测距标志  清零可以开始下次测距
//			printf("结/n");
		}
		
		EXTI_ClearITPendingBit(EXTI_Line1);     //清除中断标志位
	 } 
}

// IO 线中断，中断口为PB11 接红外接收头的数据管脚
void EXTI15_10_IRQHandler(void)
{
	uint8_t pulse_time = 0;
  uint8_t leader_code_flag = 0; /* 引导码标志位，当引导码出现时，表示一帧数据开始 */
  uint8_t irda_data = 0;        /* 数据暂存位 */
  
  if(EXTI_GetITStatus(EXTI_Line15) != RESET) /* 确保是否产生了EXTI Line中断 */
	{   
    while(1)
    {
      if( IrDa_DATA_IN()== SET )        /* 只测量高电平的时间 */
      {       
        pulse_time = Get_Pulse_Time();
        
        /* >=5ms 不是有用信号 当出现干扰或者连发码时，也会break跳出while(1)循环 */
        if( pulse_time >= 250 )                
        {
          break; /* 跳出while(1)循环 */
        }
        
        if(pulse_time>=200 && pulse_time<250)         /* 获得前导位 4ms~4.5ms */
        {
          leader_code_flag = 1;
        }
        else if(pulse_time>=10 && pulse_time<50)      /* 0.56ms: 0.2ms~1ms */
        {
          irda_data = 0;
        }
        else if(pulse_time>=50 && pulse_time<100)     /* 1.68ms：1ms~2ms */
        {
          irda_data =1 ; 
        }        
        else if( pulse_time>=100 && pulse_time<=200 ) /* 2.1ms：2ms~4ms */
        {/* 连发码，在第二次中断出现 */
          frame_flag = 1;               /* 一帧数据接收完成 */
          frame_cnt++;                  /* 按键次数加1 */
          isr_cnt ++;                   /* 进中断一次加1 */
          break;                        /* 跳出while(1)循环 */
        }
        
        if( leader_code_flag == 1 )
        {/* 在第一次中断中完成 */
          frame_data <<= 1;
          frame_data += irda_data;
          frame_cnt = 0;
          isr_cnt = 1;
        }
      }      
    }// while(1)   
		EXTI_ClearITPendingBit(EXTI_Line15);     //清除中断标志位
    //LED2_TOGGLE;
	}  
}
/**
  * @}
  */ 


/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
